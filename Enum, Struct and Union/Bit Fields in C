#include <stdio.h>

// A simple representation of the date
struct date {
	unsigned int d;
	unsigned int m;
	unsigned int y;
};

int main()
{
	printf("Size of date is %lu bytes\n",
		sizeof(struct date));
	struct date dt = { 31, 12, 2014 };
	printf("Date is %d/%d/%d", dt.d, dt.m, dt.y);
}




#include <stdio.h>

// Space optimized representation of the date
struct date {
	// d has value between 0 and 31, so 5 bits
	// are sufficient
	int d : 5;

	// m has value between 0 and 15, so 4 bits
	// are sufficient
	int m : 4;

	int y;
};

int main()
{
	printf("Size of date is %lu bytes\n",
		sizeof(struct date));
	struct date dt = { 31, 12, 2014 };
	printf("Date is %d/%d/%d", dt.d, dt.m, dt.y);
	return 0;
}




#include <stdio.h>

// A structure without forced alignment
struct test1 {
	unsigned int x : 5;
	unsigned int y : 8;
};

// A structure with forced alignment
struct test2 {
	unsigned int x : 5;
	unsigned int : 0;
	unsigned int y : 8;
};

int main()
{
	printf("Size of test1 is %lu bytes\n",
		sizeof(struct test1));
	printf("Size of test2 is %lu bytes\n",
		sizeof(struct test2));
	return 0;
}




#include <stdio.h>
struct test {
	unsigned int x : 5;
	unsigned int y : 5;
	unsigned int z;
};
int main()
{
	struct test t;

	// Uncommenting the following line will make
	// the program compile and run
	printf("Address of t.x is %p", &t.x);

	// The below line works fine as z is not a
	// bit field member
	printf("Address of t.z is %p", &t.z);
	return 0;
}
